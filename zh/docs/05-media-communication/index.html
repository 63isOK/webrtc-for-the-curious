<!doctype html><html lang=zh><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="我可以从WebRTC的媒体通信中得到什么？ #  WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。
WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。
WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。
它是如何工作的？ #  WebRTC使用RFC 1889中定义的两个既有协议RTP和RTCP。
RTP是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。
RTCP是用于传达有关呼叫的元数据的协议。其格式非常灵活，因此您可以添加所需的任何内容。这用于传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应网络状况变化所必需的双向通信能力。
延迟与质量 #  实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。
现实世界的局限性 #  下面这些限制都是由现实世界的局限性引起的。这些都是您网络需要考虑的特性。
带宽 #  带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。
当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。
传输时间 #  传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。
抖动 #  抖动是传输时间可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。
数据包丢失 #  数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也并不算是罕见的情况！
最大传输单位（MTU） #  最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据打包为小数据包。
根据您采用的网络路径，MTU也将有所不同。您可以使用Path MTU Discovery之类的协议来确定可以发送的最大数据包大小。
Media 101（媒体格式基础知识） #  Codec（编解码器） #  Frame Types（帧类型） #  RTP #  Packet Format（包格式） #  每个RTP数据包都具有以下结构：
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | ."><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="媒体通信"><meta property="og:description" content="我可以从WebRTC的媒体通信中得到什么？ #  WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。
WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。
WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。
它是如何工作的？ #  WebRTC使用RFC 1889中定义的两个既有协议RTP和RTCP。
RTP是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。
RTCP是用于传达有关呼叫的元数据的协议。其格式非常灵活，因此您可以添加所需的任何内容。这用于传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应网络状况变化所必需的双向通信能力。
延迟与质量 #  实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。
现实世界的局限性 #  下面这些限制都是由现实世界的局限性引起的。这些都是您网络需要考虑的特性。
带宽 #  带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。
当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。
传输时间 #  传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。
抖动 #  抖动是传输时间可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。
数据包丢失 #  数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也并不算是罕见的情况！
最大传输单位（MTU） #  最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据打包为小数据包。
根据您采用的网络路径，MTU也将有所不同。您可以使用Path MTU Discovery之类的协议来确定可以发送的最大数据包大小。
Media 101（媒体格式基础知识） #  Codec（编解码器） #  Frame Types（帧类型） #  RTP #  Packet Format（包格式） #  每个RTP数据包都具有以下结构：
 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |V=2|P|X| CC |M| PT | Sequence Number | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Timestamp | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Synchronization Source (SSRC) identifier | +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ | Contributing Source (CSRC) identifiers | | ."><meta property="og:type" content="article"><meta property="og:url" content="https://webrtcforthecurious.com/zh/docs/05-media-communication/"><meta property="article:modified_time" content="2020-09-24T16:13:09+08:00"><meta property="og:site_name" content="给好奇者的WebRTC"><title>媒体通信 | 给好奇者的WebRTC</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=alternate hreflang=en href=https://webrtcforthecurious.com/docs/05-media-communication/ title="Media Communication"><link rel=alternate hreflang=tr href=https://webrtcforthecurious.com/tr/docs/05-media-communication/ title="Media Communication"><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/zh.search.min.b4d991184ab976cb25f932437be6b20adb27bfb0a438f864a9bc5aaa6e5905f5.js integrity="sha256-tNmRGEq5dssl+TJDe+ayCtsnv7CkOPhkqbxaqm5ZBfU="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/zh><span>给好奇者的WebRTC</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/zh/docs/01-what-why-and-how/>是什么，为什么，如何使用</a></li><li><a href=/zh/docs/02-signaling/>信令</a></li><li><a href=/zh/docs/03-connecting/>连接</a></li><li><a href=/zh/docs/04-securing/>安全性</a></li><li><a href=/zh/docs/05-media-communication/ class=active>媒体通信</a></li><li><a href=/zh/docs/06-data-communication/>数据通信</a></li><li><a href=/zh/docs/07-applied-webrtc/>WebRTC应用场景</a></li><li><a href=/zh/docs/08-debugging/>调试</a></li><li><a href=/zh/docs/09-history-of-webrtc/>历史</a></li><li><a href=/zh/docs/10-faq/>常见问题</a></li><li><a href=/zh/docs/11-contributing/>贡献</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>媒体通信</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#延迟与质量>延迟与质量</a><ul><li><a href=#现实世界的局限性>现实世界的局限性</a></li></ul></li><li><a href=#media-101媒体格式基础知识>Media 101（媒体格式基础知识）</a><ul><li><a href=#codec编解码器>Codec（编解码器）</a></li><li><a href=#frame-types帧类型>Frame Types（帧类型）</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#packet-format包格式>Packet Format（包格式）</a></li><li><a href=#extensions扩展>Extensions（扩展）</a></li><li><a href=#mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）</a></li><li><a href=#negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）</a></li><li><a href=#senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）</a></li><li><a href=#generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）</a></li></ul></li><li><a href=#how-rtprtcp-solve-problems>How RTP/RTCP solve problems</a></li><li><a href=#rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的</a><ul><li><a href=#否定确认>否定确认</a></li><li><a href=#forward-error-correction前向纠错>Forward Error Correction（前向纠错）</a></li><li><a href=#congestion-control拥塞控制>Congestion Control（拥塞控制）</a></li><li><a href=#jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=我可以从webrtc的媒体通信中得到什么>我可以从WebRTC的媒体通信中得到什么？
<a class=anchor href=#%e6%88%91%e5%8f%af%e4%bb%a5%e4%bb%8ewebrtc%e7%9a%84%e5%aa%92%e4%bd%93%e9%80%9a%e4%bf%a1%e4%b8%ad%e5%be%97%e5%88%b0%e4%bb%80%e4%b9%88>#</a></h1><p>WebRTC允许您发送和接收无限多条音频和视频流。您可以在通话期间随时添加和删除这些流。这些流可以全部独立，也可以捆绑在一起！您甚至可以将网络摄像头的音频/视频放到您桌面的视频流中，然后将此视频流以feed的形式发送出去。</p><p>WebRTC协议与编解码器无关。底层传输支持所有格式的内容，即使是还不存在的格式！ 但是，您正与之通信的WebRTC代理可能没有必要的工具来接受它。</p><p>WebRTC针对动态网络状况也有对应的处理方案。在通话过程中，带宽可能会增加或减少。 甚至可能突然间大量丢包。该协议对所有这类问题的处理都做了相应的设计。WebRTC根据网络状况作出响应，并尝试利用可用资源为您提供最佳体验。</p><h2 id=它是如何工作的>它是如何工作的？
<a class=anchor href=#%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84>#</a></h2><p>WebRTC使用<a href=https://tools.ietf.org/html/rfc1889>RFC 1889</a>中定义的两个既有协议RTP和RTCP。</p><p>RTP是承载媒体的协议。它为视频的实时传输而设计。它没有规定有关延迟或可靠性的任何规则，但是为您提供了实现这些规则的工具。RTP提供了流的设计，因此您可以通过一个连接发布多个媒体源。它还为您提供了完善媒体传递途径所需的计时和排序信息。</p><p>RTCP是用于传达有关呼叫的元数据的协议。其格式非常灵活，因此您可以添加所需的任何内容。这用于传达有关呼叫的统计信息。也是处理分组丢失和实现拥塞控制的必备特性。它为您提供了响应网络状况变化所必需的双向通信能力。</p><h2 id=延迟与质量>延迟与质量
<a class=anchor href=#%e5%bb%b6%e8%bf%9f%e4%b8%8e%e8%b4%a8%e9%87%8f>#</a></h2><p>实时媒体就是要在延迟和质量之间进行权衡。您愿意忍受的延迟时间越长，可以预期的视频质量就越高。</p><h3 id=现实世界的局限性>现实世界的局限性
<a class=anchor href=#%e7%8e%b0%e5%ae%9e%e4%b8%96%e7%95%8c%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7>#</a></h3><p>下面这些限制都是由现实世界的局限性引起的。这些都是您网络需要考虑的特性。</p><h4 id=带宽>带宽
<a class=anchor href=#%e5%b8%a6%e5%ae%bd>#</a></h4><p>带宽是可以在给定路径上传输的最大数据速率。注意这不是一个静态数字，这一点很重要。随着越来越多（或越少）的人使用路由，带宽将发生变化。</p><p>当您尝试发送的数据超过可用带宽时，您将遇到网络拥塞的情况。</p><h4 id=传输时间>传输时间
<a class=anchor href=#%e4%bc%a0%e8%be%93%e6%97%b6%e9%97%b4>#</a></h4><p>传输时间指的是一个数据包到达目标需要多长时间。像带宽一样，这不是常量。传输时间随时可能波动。</p><h4 id=抖动>抖动
<a class=anchor href=#%e6%8a%96%e5%8a%a8>#</a></h4><p>抖动是<code>传输时间</code>可能会变化导致的现象。有时您会看到收到的数据包突然爆炸式增加。网络路径上的任何硬件都可能引入这个问题。</p><h4 id=数据包丢失>数据包丢失
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%8c%85%e4%b8%a2%e5%a4%b1>#</a></h4><p>数据包丢失是指消息在传输中丢失。丢失率可能是稳定的，也可能突然增加。这也并不算是罕见的情况！</p><h4 id=最大传输单位mtu>最大传输单位（MTU）
<a class=anchor href=#%e6%9c%80%e5%a4%a7%e4%bc%a0%e8%be%93%e5%8d%95%e4%bd%8dmtu>#</a></h4><p>最大传输单位是指单个数据包的最大限制。您无法在网络上发送一个巨大的消息。在协议级别上，您需要将数据打包为小数据包。</p><p>根据您采用的网络路径，MTU也将有所不同。您可以使用<a href=https://tools.ietf.org/html/rfc1191>Path MTU Discovery</a>之类的协议来确定可以发送的最大数据包大小。</p><h2 id=media-101媒体格式基础知识>Media 101（媒体格式基础知识）
<a class=anchor href=#media-101%e5%aa%92%e4%bd%93%e6%a0%bc%e5%bc%8f%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86>#</a></h2><h3 id=codec编解码器>Codec（编解码器）
<a class=anchor href=#codec%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8>#</a></h3><h3 id=frame-types帧类型>Frame Types（帧类型）
<a class=anchor href=#frame-types%e5%b8%a7%e7%b1%bb%e5%9e%8b>#</a></h3><h2 id=rtp>RTP
<a class=anchor href=#rtp>#</a></h2><h3 id=packet-format包格式>Packet Format（包格式）
<a class=anchor href=#packet-format%e5%8c%85%e6%a0%bc%e5%bc%8f>#</a></h3><p>每个RTP数据包都具有以下结构：</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|X|  CC   |M|     PT      |       Sequence Number         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           Timestamp                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Synchronization Source (SSRC) identifier            |
+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
|            Contributing Source (CSRC) identifiers             |
|                             ....                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v>Version (V)
<a class=anchor href=#version-v>#</a></h4><p><code>Version</code>总是2。</p><h4 id=padding-p>Padding (P)
<a class=anchor href=#padding-p>#</a></h4><p><code>Padding</code>是控制有效载荷是否具有填充值的布尔值。</p><p>有效负载的最后一个字节包含添加了多少填充字节的计数。</p><h4 id=extension-x>Extension (X)
<a class=anchor href=#extension-x>#</a></h4><p>如果设置的话，RTP报头将有扩展段（可选）。这点将在下面更详细地描述。</p><h4 id=csrc-count-cc>CSRC count (CC)
<a class=anchor href=#csrc-count-cc>#</a></h4><p>在<code>SSRC</code>之后，有效负载之前的<code>CSRC</code>标识符的数量。</p><h4 id=marker-m>Marker (M)
<a class=anchor href=#marker-m>#</a></h4><p>标记位没有预设含义，由用户决定。</p><p>在某些情况下，它是在用户讲话时设置的。它还通常用于标记关键帧。</p><h4 id=payload-type-pt>Payload Type (PT)
<a class=anchor href=#payload-type-pt>#</a></h4><p><code>Payload Type</code>（负载类型）是此数据包所承载的编解码器的唯一标识符。</p><p>对于WebRTC，<code>Payload Type</code>是动态的。一个呼叫中的VP8可能与另一个呼叫中的不同。呼叫中的Offerer确定<code>Payload Type</code>到<code>Session Description</code>（会话描述符）中的编解码器的映射。</p><h4 id=sequence-number>Sequence Number
<a class=anchor href=#sequence-number>#</a></h4><p><code>Sequence Number</code>（序列号）用于对流中的数据包进行排序。每次发送数据包时，<code>Sequence Number</code>都会增加1。</p><p>RTP被设计为可以在有损网络上使用。这为接收器提供了一种检测数据包何时丢失的方法。</p><h4 id=timestamp>Timestamp
<a class=anchor href=#timestamp>#</a></h4><p>此数据包的采样时刻。这不是全局时钟，而是在当前媒体流中所经过的时间。</p><h4 id=synchronization-source-ssrc>Synchronization Source (SSRC)
<a class=anchor href=#synchronization-source-ssrc>#</a></h4><p><code>SSRC</code>是此流的唯一标识符。 这使您可以在单个流上传输多个媒体流。</p><h4 id=contributing-source-csrc>Contributing Source (CSRC)
<a class=anchor href=#contributing-source-csrc>#</a></h4><p>一个列表，用于表示哪些<code>SSRC</code>参与到了这个数据包中。</p><p>这通常用于语音指示器。假设在服务器端，您将多个音频源组合到一个单独的RTP流中。然后，您可以在此字段中表示<code>输入流A和C此时正在讲话</code>。</p><h3 id=extensions扩展>Extensions（扩展）
<a class=anchor href=#extensions%e6%89%a9%e5%b1%95>#</a></h3><h3 id=mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）
<a class=anchor href=#mapping-payload-types-to-codecs%e5%b0%86%e8%b4%9f%e8%bd%bd%e7%b1%bb%e5%9e%8b%e6%98%a0%e5%b0%84%e5%88%b0%e7%bc%96%e8%a7%a3%e7%a0%81%e5%99%a8>#</a></h3><h2 id=rtcp>RTCP
<a class=anchor href=#rtcp>#</a></h2><h3 id=packet-format>Packet Format
<a class=anchor href=#packet-format>#</a></h3><p>每个RTCP数据包都具有以下结构：</p><pre><code> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|V=2|P|    RC   |       PT      |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                            Payload                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre><h4 id=version-v-1>Version (V)
<a class=anchor href=#version-v-1>#</a></h4><p><code>Version</code>总是2。</p><h4 id=padding-p-1>Padding (P)
<a class=anchor href=#padding-p-1>#</a></h4><p><code>Padding</code>是控制有效载荷是否具有填充值的布尔值。</p><p>有效负载的最后一个字节包含添加了多少填充字节的计数。</p><h4 id=reception-report-count-rc>Reception Report Count (RC)
<a class=anchor href=#reception-report-count-rc>#</a></h4><p>此数据包中的报告数。单个RTCP数据包可以包含多个事件。</p><h4 id=packet-type-pt>Packet Type (PT)
<a class=anchor href=#packet-type-pt>#</a></h4><p>指示RTCP数据包类型的唯一标识符。WebRTC代理不需要支持所有这些类型，并且代理之间的支持能力可以是不同的。下面这些是您可能经常看到的类型。</p><ul><li>完整的帧内请求（FIR）-<code>192</code></li><li>否定确认（NACK）-<code>193</code></li><li>发送方报告-<code>200</code></li><li>接收方报告-<code>201</code></li><li>通用RTP反馈-<code>205</code></li></ul><p>这些分组类型的意义将在下面更详细地描述。</p><h3 id=full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）
<a class=anchor href=#full-intra-frame-request%e5%ae%8c%e6%95%b4%e7%9a%84%e5%b8%a7%e5%86%85%e8%af%b7%e6%b1%82>#</a></h3><p>此RTCP消息通知发送者它需要发送完整图像。这适用于编码器为您提供了帧的一部分，但您无法对其进行解码的情况。</p><p>之所以会发生这种情况，是因为您有很多数据包丢失，或者解码器崩溃了。</p><h3 id=negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）
<a class=anchor href=#negative-acknowledgements%e5%90%a6%e5%ae%9a%e7%a1%ae%e8%ae%a4>#</a></h3><p>NACK请求发送方重新发送单个RTP数据包。这通常是由于RTP数据包丢失而引起的，但是也可能由于延迟而发生。</p><p>与请求重新发送整个帧相比，NACK的带宽效率要高得多。由于RTP将数据包分解成很小的块，因此您实际上只是在请求丢失的一个很小的部分。</p><h3 id=senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）
<a class=anchor href=#senderreceiver-reports%e5%8f%91%e9%80%81%e6%96%b9%e6%8e%a5%e6%94%b6%e6%96%b9%e6%8a%a5%e5%91%8a>#</a></h3><p>这些报告用于在代理之间发送统计信息。它传达了实际接收到的和抖动的数据包数量。</p><p>这些报告可用于常规、诊断或者基本的拥塞控制。</p><h3 id=generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）
<a class=anchor href=#generic-rtp-feedback%e9%80%9a%e7%94%a8rtp%e5%8f%8d%e9%a6%88>#</a></h3><h2 id=how-rtprtcp-solve-problems>How RTP/RTCP solve problems
<a class=anchor href=#how-rtprtcp-solve-problems>#</a></h2><p>RTP and RTCP then work together to solve all the problems caused by networks. These techniques are still constantly changing!</p><h2 id=rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的
<a class=anchor href=#rtprtcp%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e9%97%ae%e9%a2%98%e7%9a%84>#</a></h2><p>RTP和RTCP需要协同解决网络引起的所有问题。这些技术仍在不断进化中！</p><h3 id=否定确认>否定确认
<a class=anchor href=#%e5%90%a6%e5%ae%9a%e7%a1%ae%e8%ae%a4>#</a></h3><p>也称为NACK。这是使用RTP处理数据包丢失的一种方法。</p><p>NACK是发送回发送方以请求重发的RTCP消息。接收方使用SSRC和序列号制作RTCP消息。 如果发送方没有可用于重新发送的RTP数据包，则忽略该消息。</p><h3 id=forward-error-correction前向纠错>Forward Error Correction（前向纠错）
<a class=anchor href=#forward-error-correction%e5%89%8d%e5%90%91%e7%ba%a0%e9%94%99>#</a></h3><p>简称为FEC。处理丢包的另一种方法。FEC指的是发送方多次重复发送相同的数据，甚至是在接收方没有要求的情况下发送。这可以在RTP级别完成，甚至可以在编解码器以下的层级完成。</p><p>在呼叫的数据丢包率比较稳定的情况下，FEC比NACK好得多。对于NACK，必须先请求然后重新传输数据包，这样的数据往返对性能影响很大。</p><h3 id=congestion-control拥塞控制>Congestion Control（拥塞控制）
<a class=anchor href=#congestion-control%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6>#</a></h3><p>拥塞控制是根据网络属性调整媒体的行为。如果带宽较小，则需要发送质量较低的视频。</p><p>拥塞控制就是要权衡取舍。</p><h3 id=jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）
<a class=anchor href=#jitterbuffer%e6%8a%96%e5%8a%a8%e7%bc%93%e5%86%b2>#</a></h3></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div class=book-languages tabindex=0 aria-haspopup=true><ul><li class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</li></ul><ul class=book-languages-list><li><a href=https://webrtcforthecurious.com/docs/05-media-communication/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
English</a></li><li><a href=https://webrtcforthecurious.com/tr/docs/05-media-communication/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Turkish</a></li><li><a href=https://webrtcforthecurious.com/fa/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
Persian</a></li><li class=active><a href=https://webrtcforthecurious.com/zh/ class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></li></ul></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/commit/6268b1309579e0c56a549d7ceb91723bcff6f4f5 title="最后修改者 Cliff Han | September 24, 2020" target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt=Calendar>
<span>September 24, 2020</span></a></div><div><a class="flex align-center" href=https://github.com/webrtc-for-the-curious/webrtc-for-the-curious/edit/master/content/content.zh-cn/docs/05-media-communication.md target=_blank rel=noopener><img src=/svg/edit.svg class=book-icon alt=Edit>
<span>编辑本页</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#它是如何工作的>它是如何工作的？</a></li><li><a href=#延迟与质量>延迟与质量</a><ul><li><a href=#现实世界的局限性>现实世界的局限性</a></li></ul></li><li><a href=#media-101媒体格式基础知识>Media 101（媒体格式基础知识）</a><ul><li><a href=#codec编解码器>Codec（编解码器）</a></li><li><a href=#frame-types帧类型>Frame Types（帧类型）</a></li></ul></li><li><a href=#rtp>RTP</a><ul><li><a href=#packet-format包格式>Packet Format（包格式）</a></li><li><a href=#extensions扩展>Extensions（扩展）</a></li><li><a href=#mapping-payload-types-to-codecs将负载类型映射到编解码器>Mapping Payload Types to Codecs（将负载类型映射到编解码器）</a></li></ul></li><li><a href=#rtcp>RTCP</a><ul><li><a href=#packet-format>Packet Format</a></li><li><a href=#full-intra-frame-request完整的帧内请求>Full INTRA-frame Request（完整的帧内请求）</a></li><li><a href=#negative-acknowledgements否定确认>Negative ACKnowledgements（否定确认）</a></li><li><a href=#senderreceiver-reports发送方接收方报告>Sender/Receiver Reports（发送方/接收方报告）</a></li><li><a href=#generic-rtp-feedback通用rtp反馈>Generic RTP Feedback（通用RTP反馈）</a></li></ul></li><li><a href=#how-rtprtcp-solve-problems>How RTP/RTCP solve problems</a></li><li><a href=#rtprtcp是如何解决问题的>RTP/RTCP是如何解决问题的</a><ul><li><a href=#否定确认>否定确认</a></li><li><a href=#forward-error-correction前向纠错>Forward Error Correction（前向纠错）</a></li><li><a href=#congestion-control拥塞控制>Congestion Control（拥塞控制）</a></li><li><a href=#jitterbuffer抖动缓冲>JitterBuffer（抖动缓冲）</a></li></ul></li></ul></nav></aside></main></body></html>